import { GESPREK_TARGET_MESSAGES_COUNT, GESPREK_CHUNK_SIZE } from "@/config";
import { Deelnemer } from "@/data/deelnemers";
import { model } from "@/lib/ai";
import { generateObject } from "ai";
import { z } from "zod";
import { addTimestampsToMessages } from "../utils";
import { createLogger } from "@/lib/logger";

const logger = createLogger("genereer-gesprek-berichten");

export type GeneratedMessage = {
  message: string;
  deelnemerName: string;
  deelnemerId: number;
};

type AIGeneratedMessage = {
  deelnemerName: string;
  messages: string[]; // 1-3 berichten per burst
};

/**
 * Build a Zod schema for the messages that can be generated by the AI, linked to enumerate of available deelnemers.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns A Zod schema for the messages of the conversation.
 */
export function buildMessageSchema(deelnemers: Deelnemer[]) {
  const deelnemerNames = deelnemers.map((d) => d.name);

  return z.array(
    z.object({
      deelnemerName: z
        .enum(deelnemerNames as [string, ...string[]])
        .describe(
          `De naam van de politicus die deze berichten verstuurt. Moet een van de volgende zijn: ${deelnemerNames.join(
            ", "
          )}`
        ),
      messages: z
        .array(z.string())
        .min(1)
        .max(3)
        .describe(
          "1-3 korte chat-berichten die deze politicus in één burst stuurt. Elk bericht is zeer kort (1 zin of minder)."
        ),
    })
  );
}

/**
 * Flatten AI generated message bursts into individual messages and add deelnemer IDs.
 * Each burst (1-3 messages from one politicus) becomes multiple individual GeneratedMessage objects.
 * @param bursts - The generated message bursts from the AI.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns Flattened array of individual messages with deelnemer IDs.
 */
export function addDeelnemerIdsToAIGeneratedMessages(
  bursts: AIGeneratedMessage[],
  deelnemers: Deelnemer[]
): GeneratedMessage[] {
  const deelnemerNameToId = Object.fromEntries(
    deelnemers.map((d) => [d.name, d.id])
  );

  // Flatten bursts into individual messages
  const flattenedMessages: GeneratedMessage[] = [];
  
  for (const burst of bursts) {
    const deelnemerId = deelnemerNameToId[burst.deelnemerName];
    
    for (const message of burst.messages) {
      flattenedMessages.push({
        message,
        deelnemerName: burst.deelnemerName,
        deelnemerId,
      });
    }
  }

  return flattenedMessages;
}

/**
 * Build the system message for the AI.
 * @param opties - The options for the conversation.
 * @returns The system message for the AI.
 */
const buildSystemMessage = (opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
}) => {
  return `
    # Rol
    Je bent een expert in het schrijven van realistische Nederlandse politieke onderhandelingen. 
    Je schrijft een constructief gesprek tussen politici die tot een compromis proberen te komen.
    
    # Onderwerp
    ${opties.onderwerp}
    
    # Deelnemers
    ${opties.deelnemers
      .map(
        (deelnemer) => `
    - ${deelnemer.name}
      - Partij: ${deelnemer.partij.name}
      - Zetels: ${deelnemer.partij.zetels}
      - Tone of voice: ${deelnemer.toneOfVoice}${
          deelnemer.persoonlijkeDetails
            ? `\n      - Achtergrond: ${deelnemer.persoonlijkeDetails}`
            : ""
        }${
          deelnemer.typischeUitspraken && deelnemer.typischeUitspraken.length > 0
            ? `\n      - Typische uitspraken: ${deelnemer.typischeUitspraken.join("; ")}`
            : ""
        }
      - Standpunten:
          ${deelnemer.partij.programma.standpunten
            .map((standpunt) => `- ${standpunt}`)
            .join("\n          ")}
    `
      )
      .join("\n")}
    
    # Belangrijke Regels
    - Het gesprek moet realistisch en constructief zijn, gericht op het vinden van een compromis
    - Laat politici:
      * Hun standpunten duidelijk maken
      * Naar elkaar luisteren en reageren
      * Kritische vragen stellen
      * Bezwaren uiten maar ook openingen zoeken
      * Langzaam naar elkaar toe bewegen
    - Het gesprek moet een verhaalboog hebben: begin (standpunten), midden (discussie), einde (toenadering)
    - Het gesprek moet eindigen met ruimte voor een compromis of concrete stappen richting oplossing
    - Blijf realistisch: politici blijven hun kernwaarden verdedigen maar zijn bereid te onderhandelen
    
    # Chat-stijl Format
    - Dit is een GROEPSCHAT. Politici sturen korte, snelle berichten zoals in WhatsApp
    - Elk persoon stuurt 1-3 berichten per beurt (een "burst")
      * 1 bericht = korte reactie: "Precies!", "Totaal mee oneens", "Dat klopt niet"
      * 2-3 berichten = uitgebreidere reactie of argument opbouwen
    - Berichten zijn ZEER KORT:
      * Meestal 1 korte zin of minder
      * Vaak halve zinnen of uitroepen: "Precies!", "Dat slaat nergens op.", "Kom op zeg."
      * Maximum 15-20 woorden per bericht
    - Emojis zijn toegestaan en moeten spaarzaam gebruikt worden:
      * Vooral door jongere/informelere politici (Rob Jetten, Laurens Dassen)
      * Voorbeelden: 🔥 💪 🤔 ✅ ❌ 👍 😅 🎯
      * Oudere/formelere politici gebruiken zelden of nooit emojis
    
    # Reactieve Flow - WIE reageert op WIE
    - Politici REAGEREN direct op wat er net gezegd is
    - Bepaal logisch wie getriggerd wordt door de laatste spreker:
      * Tegenpolen reageren vaak op elkaar: Wilders ↔ Timmermans, PVV ↔ GL-PvdA
      * Coalitiegenoten steunen elkaar: VVD + NSC, GL-PvdA + D66 + PvdD
      * Partijen met overlap kunnen kritisch zijn: VVD vs JA21, BBB vs PVV
    - Als iemand een provocerende uitspraak doet, laat anderen reageren
    - Niet elke politicus hoeft elke ronde te spreken
    - Laat het gesprek natuurlijk vloeien: wie zou nu logisch reageren?
    
    - Gebruik de partijstandpunten en tone of voice van elke politicus
    - Houd het constructief maar wel met realistische spanning en meningsverschillen
    `;
};

export async function genereerGesprekBerichten(opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
  startAt: Date;
  endAt: Date;
}) {
  const generatedMessages: GeneratedMessage[] = [];
  const systemPrompt = buildSystemMessage(opties);

  let phase: "begin" | "midden" | "einde" = "begin";
  let chunkCount = 0;
  const maxChunks = Math.ceil(
    GESPREK_TARGET_MESSAGES_COUNT / GESPREK_CHUNK_SIZE
  );

  logger.info(
    `Generating ${GESPREK_TARGET_MESSAGES_COUNT} messages in ~${maxChunks} batches of ~${GESPREK_CHUNK_SIZE} messages (kleinere batches voor natuurlijker gesprek)`,
    { phase }
  );

  while (generatedMessages.length < GESPREK_TARGET_MESSAGES_COUNT) {
    chunkCount++;

    const progress = generatedMessages.length / GESPREK_TARGET_MESSAGES_COUNT;

    if (progress < 0.3) {
      phase = "begin";
    } else if (progress < 0.6) {
      phase = "midden";
    } else {
      phase = "einde";
    }

    const isLastChunk =
      chunkCount === maxChunks ||
      generatedMessages.length >=
        GESPREK_TARGET_MESSAGES_COUNT - GESPREK_CHUNK_SIZE;

    const remainingMessages =
      GESPREK_TARGET_MESSAGES_COUNT - generatedMessages.length;

    const messagesThisChunk = Math.min(GESPREK_CHUNK_SIZE, remainingMessages);

    logger.debug(
      `Generating batch ${chunkCount}/${maxChunks} with ${messagesThisChunk} messages (3-4 turns)`,
      { phase }
    );

    const conversationHistoryContext =
      generatedMessages.length > 0
        ? `\n## Gesprek tot nu toe:\n${generatedMessages
            .map((m) => `${m.deelnemerName}: ${m.message}`)
            .join("\n")}\n`
        : "";

    const phaseInstructions = {
      begin:
        "Dit is het BEGIN van het gesprek. Laat de politici het onderwerp introduceren en hun standpunten helder uiteenzetten. Toon waar ze van elkaar verschillen.",
      midden:
        "Dit is het MIDDEN van het gesprek. De discussie wordt dieper. Politici stellen kritische vragen, uiten bezwaren, maar beginnen ook overeenkomsten te zien. Toon realistische spanning maar ook openheid.",
      einde:
        "Dit is het EINDE van het gesprek. Politici moeten nu naar elkaar toebewegen. Laat zien dat er ruimte is voor een compromis of dat er concrete vervolgstappen worden gezet. Eindig constructief met perspectief op een oplossing.",
    };

    // Bepaal laatste spreker(s) voor context
    const lastSpeakers = generatedMessages.length > 0
      ? generatedMessages.slice(-3).map(m => ({
          name: m.deelnemerName,
          message: m.message
        }))
      : [];
    
    const lastSpeakerContext = lastSpeakers.length > 0
      ? `\n## Laatste berichten (reageer hierop):\n${lastSpeakers.map(s => `${s.name}: ${s.message}`).join('\n')}\n`
      : '';

    const userPrompt = isLastChunk
      ? `${conversationHistoryContext}${lastSpeakerContext}

## Fase: ${phase.toUpperCase()} 
${phaseInstructions[phase]}

DIT IS HET LAATSTE STUK. Genereer ${messagesThisChunk} berichten die het gesprek AFSLUITEN.
Het gesprek moet eindigen met toenadering en perspectief op een compromis of oplossing. 
Laat politici concrete vervolgstappen noemen of ruimte laten voor een gezamenlijke aanpak.

WIE zou logisch reageren op de laatste sprekers? Denk na over:
- Wie wordt getriggerd door wat er net gezegd is?
- Welke politici zouden elkaar willen steunen of tegenspreken?
- Laat het gesprek natuurlijk naar een conclusie vloeien.`
      : `${conversationHistoryContext}${lastSpeakerContext}

## Fase: ${phase.toUpperCase()}
${phaseInstructions[phase]}

Genereer de volgende ${messagesThisChunk} berichten (dit zijn ${messagesThisChunk} INDIVIDUELE berichten, dus 3-4 politici die elk 1-3 berichten sturen).

WIE zou logisch reageren op wat er net gezegd is? Denk na over:
- Wie wordt direct getriggerd door de laatste spreker?
- Zijn er tegenpolen die op elkaar reageren?
- Zijn er coalitiegenoten die elkaar steunen?
- Niet iedereen hoeft elke ronde te spreken - focus op natuurlijke reacties.`;

    try {
      const response = await generateObject({
        model,
        schema: buildMessageSchema(opties.deelnemers),
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
      });

      const aiMessages = response.object;
      const newMessages = addDeelnemerIdsToAIGeneratedMessages(
        aiMessages,
        opties.deelnemers
      );

      if (newMessages.length === 0) {
        logger.warn(
          `No messages generated for chunk ${chunkCount}`,
          { chunkCount }
        );
        break;
      }

      generatedMessages.push(...newMessages);
      logger.debug(
        `Generated ${newMessages.length} messages for chunk ${chunkCount}`,
        { chunkCount, totalMessages: generatedMessages.length }
      );

      if (generatedMessages.length >= GESPREK_TARGET_MESSAGES_COUNT) {
        break;
      }
    } catch (error) {
      logger.error(
        `Error generating messages for chunk ${chunkCount}`,
        error
      );
      if (generatedMessages.length === 0) {
        throw error;
      }
      break;
    }
  }

  logger.info("Gesprek berichten generation completed", { 
    totalMessages: generatedMessages.length,
    targetMessages: GESPREK_TARGET_MESSAGES_COUNT 
  });

  return addTimestampsToMessages(
    generatedMessages,
    opties.startAt,
    opties.endAt
  );
}
