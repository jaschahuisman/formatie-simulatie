import { GESPREK_TARGET_MESSAGES_COUNT, GESPREK_TURNS_PER_BATCH } from "@/config";
import { Deelnemer } from "@/data/deelnemers";
import { getRandomModelConfig } from "@/lib/ai";
import { generateObject } from "ai";
import { z } from "zod";
import { addTimestampsToMessages } from "../utils";
import { createLogger } from "@/lib/logger";

const logger = createLogger("genereer-gesprek-berichten");

export type GeneratedMessage = {
  message: string;
  deelnemerName: string;
  deelnemerId: number;
};

type AIGeneratedMessage = {
  deelnemerName: string;
  messages: string[]; // 1-3 berichten per burst
};

/**
 * Build a Zod schema for the messages that can be generated by the AI, linked to enumerate of available deelnemers.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns A Zod schema for the messages of the conversation.
 */
export function buildMessageSchema(deelnemers: Deelnemer[]) {
  const deelnemerNames = deelnemers.map((d) => d.name);
  
  const MIN_TURNS = 2;
  const MAX_TURNS = 10; // Ruime limiet voor schema, we truncaten naar 3 in code
  const MIN_MESSAGES_PER_TURN = 1;
  const MAX_MESSAGES_PER_TURN = 3;

  return z
    .array(
      z.object({
        deelnemerName: z
          .enum(deelnemerNames as [string, ...string[]])
          .describe(
            `De naam van de politicus die deze berichten verstuurt. Moet een van de volgende zijn: ${deelnemerNames.join(
              ", "
            )}`
          ),
        messages: z
          .array(z.string())
          .min(MIN_MESSAGES_PER_TURN)
          .max(MAX_MESSAGES_PER_TURN)
          .describe(
            `Array van ${MIN_MESSAGES_PER_TURN} tot ${MAX_MESSAGES_PER_TURN} korte chat-berichten van deze politicus. MEESTAL 1 bericht, SOMS 2 berichten, ZELDEN 3 berichten. Minder is meer! Elk bericht is zeer kort (1 zin of minder).`
          ),
      }).describe("Een enkele beurt: één politicus die 1-3 berichten stuurt")
    )
    .min(MIN_TURNS)
    .max(MAX_TURNS)
    .describe(
      `Array van gespreksbeurten. Bij voorkeur 2-3 beurten. Elke beurt = één politicus die reageert met 1-3 berichten.`
    );
}

/**
 * Flatten AI generated message bursts into individual messages and add deelnemer IDs.
 * Each burst (1-3 messages from one politicus) becomes multiple individual GeneratedMessage objects.
 * @param bursts - The generated message bursts from the AI.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns Flattened array of individual messages with deelnemer IDs.
 */
export function addDeelnemerIdsToAIGeneratedMessages(
  bursts: AIGeneratedMessage[],
  deelnemers: Deelnemer[]
): GeneratedMessage[] {
  const deelnemerNameToId = Object.fromEntries(
    deelnemers.map((d) => [d.name, d.id])
  );

  // Flatten bursts into individual messages
  const flattenedMessages: GeneratedMessage[] = [];
  
  for (const burst of bursts) {
    const deelnemerId = deelnemerNameToId[burst.deelnemerName];
    
    for (const message of burst.messages) {
      flattenedMessages.push({
        message,
        deelnemerName: burst.deelnemerName,
        deelnemerId,
      });
    }
  }

  return flattenedMessages;
}

/**
 * Build the system message for the AI.
 * @param opties - The options for the conversation.
 * @returns The system message for the AI.
 */
const buildSystemMessage = (opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
}) => {
  return `
    # Rol
    Je bent een expert in het schrijven van realistische Nederlandse politieke onderhandelingen. 
    Je schrijft een constructief gesprek tussen politici die tot een compromis proberen te komen.
    
    # Onderwerp
    ${opties.onderwerp}
    
    # Deelnemers
    ${opties.deelnemers
      .map(
        (deelnemer) => `
    - ${deelnemer.name}
      - Partij: ${deelnemer.partij.name}
      - Zetels: ${deelnemer.partij.zetels}
      - Tone of voice: ${deelnemer.toneOfVoice}${
          deelnemer.persoonlijkeDetails
            ? `\n      - Achtergrond: ${deelnemer.persoonlijkeDetails}`
            : ""
        }${
          deelnemer.typischeUitspraken && deelnemer.typischeUitspraken.length > 0
            ? `\n      - Typische uitspraken: ${deelnemer.typischeUitspraken.join("; ")}`
            : ""
        }
      - Standpunten:
          ${deelnemer.partij.programma.standpunten
            .map((standpunt) => `- ${standpunt}`)
            .join("\n          ")}
    `
      )
      .join("\n")}
    
    # Belangrijke Regels
    - Het gesprek moet realistisch en constructief zijn, gericht op het vinden van een compromis
    - Laat politici:
      * Hun standpunten duidelijk maken
      * Naar elkaar luisteren en reageren
      * Kritische vragen stellen
      * Bezwaren uiten maar ook openingen zoeken
      * Langzaam naar elkaar toe bewegen
    - Het gesprek moet een verhaalboog hebben: begin (standpunten), midden (discussie), einde (toenadering)
    - Het gesprek moet eindigen met ruimte voor een compromis of concrete stappen richting oplossing
    - Blijf realistisch: politici blijven hun kernwaarden verdedigen maar zijn bereid te onderhandelen
    
# Chat-stijl Format
- Dit is een GROEPSCHAT. Politici sturen korte, snelle berichten zoals in WhatsApp
- Elk persoon stuurt 1-3 berichten per beurt (een "burst"):
  * MEESTAL 1 bericht: korte reactie zoals "Precies!", "Totaal mee oneens", "Dat klopt niet"
  * SOMS 2 berichten: iets uitgebreider, een argument in twee stappen
  * ZELDEN 3 berichten: alleen bij complexere punten of opbouw van argument
  * DENK NA: hoeveel berichten zijn ECHT nodig? Minder is meer!
- Berichten zijn ZEER KORT:
  * Meestal 1 korte zin of minder
  * Vaak halve zinnen of uitroepen: "Precies!", "Dat slaat nergens op.", "Kom op zeg."
  * Maximum 15-20 woorden per bericht
- Emojis zijn toegestaan en moeten spaarzaam gebruikt worden:
  * Vooral door jongere/informelere politici (Rob Jetten, Laurens Dassen)
  * Voorbeelden: 🔥 💪 🤔 ✅ ❌ 👍 😅 🎯
  * Oudere/formelere politici gebruiken zelden of nooit emojis
    
    # Reactieve Flow - WIE reageert op WIE
    - Politici REAGEREN direct op wat er net gezegd is
    - Bepaal logisch wie getriggerd wordt door de laatste spreker:
      * Tegenpolen reageren vaak op elkaar: Wilders ↔ Timmermans, PVV ↔ GL-PvdA
      * Coalitiegenoten steunen elkaar: VVD + NSC, GL-PvdA + D66 + PvdD
      * Partijen met overlap kunnen kritisch zijn: VVD vs JA21, BBB vs PVV
    - Als iemand een provocerende uitspraak doet, laat anderen reageren
    - Niet elke politicus hoeft elke ronde te spreken
    - Laat het gesprek natuurlijk vloeien: wie zou nu logisch reageren?
    
    - Gebruik de partijstandpunten en tone of voice van elke politicus
    - Houd het constructief maar wel met realistische spanning en meningsverschillen
    `;
};

export async function genereerGesprekBerichten(opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
  startAt: Date;
  endAt: Date;
}) {
  const generatedMessages: GeneratedMessage[] = [];
  const systemPrompt = buildSystemMessage(opties);

  let phase: "begin" | "midden" | "einde" = "begin";
  let batchCount = 0;

  logger.info(
    `Generating ~${GESPREK_TARGET_MESSAGES_COUNT} messages in batches of ${GESPREK_TURNS_PER_BATCH} turns (kleinere batches voor natuurlijker gesprek)`,
    { phase }
  );

  while (generatedMessages.length < GESPREK_TARGET_MESSAGES_COUNT) {
    batchCount++;

    const progress = generatedMessages.length / GESPREK_TARGET_MESSAGES_COUNT;

    if (progress < 0.3) {
      phase = "begin";
    } else if (progress < 0.6) {
      phase = "midden";
    } else {
      phase = "einde";
    }

    const remainingMessages =
      GESPREK_TARGET_MESSAGES_COUNT - generatedMessages.length;
    
    const isLastBatch = remainingMessages <= 10; // Als we dichtbij het einde zijn

    logger.debug(
      `Generating batch ${batchCount} with ${GESPREK_TURNS_PER_BATCH} turns (${remainingMessages} messages remaining)`,
      { phase, remainingMessages }
    );

    // Korte samenvatting van het gesprek (als het lang wordt)
    const conversationSummaryContext =
      generatedMessages.length > 10
        ? `\n## Samenvatting gesprek tot nu toe:\nEr zijn ${generatedMessages.length} berichten uitgewisseld. Het gesprek gaat over: ${opties.onderwerp}\n`
        : generatedMessages.length > 0
        ? `\n## Gesprek tot nu toe:\n${generatedMessages
            .map((m) => `${m.deelnemerName}: ${m.message}`)
            .join("\n")}\n`
        : "";

    const phaseInstructions = {
      begin:
        "Dit is het BEGIN van het gesprek. Laat de politici het onderwerp introduceren en hun standpunten helder uiteenzetten. Toon waar ze van elkaar verschillen.",
      midden:
        "Dit is het MIDDEN van het gesprek. De discussie wordt dieper. Politici stellen kritische vragen, uiten bezwaren, maar beginnen ook overeenkomsten te zien. Toon realistische spanning maar ook openheid.",
      einde:
        "Dit is het EINDE van het gesprek. Politici moeten nu naar elkaar toebewegen. Laat zien dat er ruimte is voor een compromis of dat er concrete vervolgstappen worden gezet. Eindig constructief met perspectief op een oplossing.",
    };

    // Laatste 5 berichten - MEEST BELANGRIJK voor reacties
    const recentMessages = generatedMessages.slice(-5);
    const lastSpeakerContext = recentMessages.length > 0
      ? `\n## ⚠️ LAATSTE BERICHTEN - REAGEER HIEROP:\n${recentMessages.map((m, i) => `[${i + 1}] ${m.deelnemerName}: "${m.message}"`).join('\n')}\n\n🎯 Lees deze laatste berichten GOED. Reageer DIRECT op wat hier gezegd wordt.\nAls je iemand bekritiseert, zorg dat het gaat over WAT DIE PERSOON NET ZEI.\n`
      : '';
    
    // Track wie er al gesproken heeft en hoe vaak
    const speakerCounts = new Map<string, number>();
    generatedMessages.forEach(m => {
      speakerCounts.set(m.deelnemerName, (speakerCounts.get(m.deelnemerName) || 0) + 1);
    });
    
    // Sorteer politici: wie heeft het minst gesproken?
    const deelnemersBySpeechCount = opties.deelnemers
      .map(d => ({
        name: d.name,
        count: speakerCounts.get(d.name) || 0
      }))
      .sort((a, b) => a.count - b.count);
    
    const leastActiveDeelnemers = deelnemersBySpeechCount
      .filter(d => d.count < 3)
      .map(d => d.name);
    
    const speakerDistributionContext = leastActiveDeelnemers.length > 0
      ? `\n## BELANGRIJK - Sprekersverdeling:\nDeze politici hebben nog weinig of niet gesproken en zouden nu aan bod moeten komen: ${leastActiveDeelnemers.join(', ')}\nVarieer de sprekers! Niet altijd dezelfde mensen laten reageren.\n`
      : '\n## BELANGRIJK - Sprekersverdeling:\nVarieer de sprekers! Laat ook andere politici aan het woord komen, niet alleen degenen die al veel gezegd hebben.\n';

    const userPrompt = isLastBatch
      ? `${conversationSummaryContext}${lastSpeakerContext}${speakerDistributionContext}

## Fase: ${phase.toUpperCase()} 
${phaseInstructions[phase]}

⚠️ DIT IS HET LAATSTE STUK - GENEREER EXACT 2 OF 3 BEURTEN ⚠️

Aantal beurten: 2 of 3 (niet meer!)
Berichten per beurt: MEESTAL 1 bericht, SOMS 2, ZELDEN 3

HARDE LIMIET: Maximum 3 politici mogen reageren. Geen 4, geen 5.

Het gesprek moet eindigen met toenadering en perspectief op een compromis of oplossing. 
Laat politici concrete vervolgstappen noemen of ruimte laten voor een gezamenlijke aanpak.

WIE zou logisch reageren op de LAATSTE BERICHTEN hierboven? Denk na over:
- Wie wordt getriggerd door wat er net gezegd is IN DE LAATSTE BERICHTEN?
- Reageer op de INHOUD van wat er net gezegd is, niet op oude discussies
- Laat het gesprek natuurlijk naar een conclusie vloeien.`
      : `${conversationSummaryContext}${lastSpeakerContext}${speakerDistributionContext}

## Fase: ${phase.toUpperCase()}
${phaseInstructions[phase]}

⚠️ GENEREER EXACT 2 OF 3 BEURTEN - ABSOLUUT NIET MEER! ⚠️

Aantal beurten: 2 of 3 (kies één van deze twee getallen)
Berichten per beurt: 1-3 berichten
  - MEESTAL 1 bericht per politicus
  - SOMS 2 berichten
  - ZELDEN 3 berichten

HARDE LIMIET: Maximum 3 politici mogen reageren in deze ronde.
Als je 4 of 5 politici wilt laten reageren: STOP. Dat is te veel.

WIE zou logisch reageren op de LAATSTE BERICHTEN hierboven? Overweeg:
- Wie wordt getriggerd door wat er in de LAATSTE BERICHTEN gezegd is?
- Reageer op de INHOUD van die specifieke berichten, niet op oude discussies
- Zijn er rivalen die op elkaar zouden reageren?
- Zijn er coalitiegenoten die elkaar zouden steunen?
- Niet iedereen hoeft te spreken - focus op natuurlijke reacties.`;

    try {
      // Selecteer random model configuratie voor variatie
      const modelConfig = getRandomModelConfig();
      
      logger.debug(`Calling AI with schema`, {
        schemaStructure: "Array of turns, each turn has deelnemerName and messages array",
        modelConfig: modelConfig.name,
        temperature: modelConfig.settings.temperature,
      });

      const response = await generateObject({
        model: modelConfig.model,
        ...modelConfig.settings,
        schema: buildMessageSchema(opties.deelnemers),
        schemaName: "PolitiekeGespreksBeurten",
        schemaDescription: "Array van EXACT 2 of 3 politieke gespreksbeurten. Elke beurt bevat de naam van een politicus en hun 1-3 korte berichten. ABSOLUUT MAXIMUM: 3 beurten. Niet 4, niet 5, maximaal 3.",
        mode: "json",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
        onFinish: ({ response: finishResponse }) => {
          logger.debug(`AI raw response (onFinish)`, {
            text: finishResponse.text,
            finishReason: finishResponse.finishReason,
            modelUsed: modelConfig.name,
          });
        },
      });

      logger.debug(`AI response received successfully`, { 
        turnsGenerated: response.object.length,
        rawResponse: JSON.stringify(response.object, null, 2)
      });

      // Truncate naar max 3 turns - AI genereert vaak 4-5 turns ondanks instructies
      const MAX_TURNS_TO_USE = 3;
      const aiMessages = response.object.length > MAX_TURNS_TO_USE
        ? response.object.slice(0, MAX_TURNS_TO_USE)
        : response.object;
      
      if (response.object.length > MAX_TURNS_TO_USE) {
        logger.info(`AI generated ${response.object.length} turns, using first ${MAX_TURNS_TO_USE}`, {
          generated: response.object.length,
          used: aiMessages.length
        });
      }

      const newMessages = addDeelnemerIdsToAIGeneratedMessages(
        aiMessages,
        opties.deelnemers
      );

      if (newMessages.length === 0) {
        logger.warn(
          `No messages generated for batch ${batchCount}`,
          { batchCount }
        );
        break;
      }

      generatedMessages.push(...newMessages);
      logger.debug(
        `Generated ${newMessages.length} messages for batch ${batchCount} (total: ${generatedMessages.length}/${GESPREK_TARGET_MESSAGES_COUNT})`,
        { batchCount, totalMessages: generatedMessages.length }
      );

      if (generatedMessages.length >= GESPREK_TARGET_MESSAGES_COUNT) {
        logger.info(`Target message count reached, stopping generation`);
        break;
      }
    } catch (error) {
      // Log detailed error information including any raw response
      const errorDetails: any = {
        errorName: error instanceof Error ? error.name : 'Unknown',
        errorMessage: error instanceof Error ? error.message : String(error),
      };

      // Try to extract raw response from AI SDK error
      if (error && typeof error === 'object') {
        // @ts-ignore - AI SDK errors may have these properties
        if (error.response) errorDetails.rawResponse = error.response;
        // @ts-ignore
        if (error.text) errorDetails.rawText = error.text;
        // @ts-ignore
        if (error.cause) errorDetails.cause = error.cause;
      }

      logger.error(
        `Error generating messages for batch ${batchCount}`,
        errorDetails
      );

      if (generatedMessages.length === 0) {
        throw error;
      }
      break;
    }
  }

  logger.info("Gesprek berichten generation completed", { 
    totalMessages: generatedMessages.length,
    targetMessages: GESPREK_TARGET_MESSAGES_COUNT 
  });

  return addTimestampsToMessages(
    generatedMessages,
    opties.startAt,
    opties.endAt
  );
}
