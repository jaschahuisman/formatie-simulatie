import { GESPREK_TARGET_MESSAGES_COUNT, GESPREK_CHUNK_SIZE } from "@/config";
import { Deelnemer } from "@/data/deelnemers";
import { model } from "@/lib/ai";
import { generateObject } from "ai";
import { z } from "zod";
import { addTimestampsToMessages } from "../utils";
import { createLogger } from "@/lib/logger";

const logger = createLogger("genereer-gesprek-berichten");

export type GeneratedMessage = {
  message: string;
  deelnemerName: string;
  deelnemerId: number;
};

type AIGeneratedMessage = {
  message: string;
  deelnemerName: string;
};

/**
 * Build a Zod schema for the messages that can be generated by the AI, linked to enumerate of available deelnemers.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns A Zod schema for the messages of the conversation.
 */
export function buildMessageSchema(deelnemers: Deelnemer[]) {
  const deelnemerNames = deelnemers.map((d) => d.name);

  return z.array(
    z.object({
      message: z.string().describe("Het bericht van de politicus"),
      deelnemerName: z
        .enum(deelnemerNames as [string, ...string[]])
        .describe(
          `De naam van de politicus die dit bericht verstuurt. Moet een van de volgende zijn: ${deelnemerNames.join(
            ", "
          )}`
        ),
    })
  );
}

/**
 * Add the deelnemer IDs to the AI generated messages.
 * @param messages - The generated messages.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns The generated messages with the deelnemer IDs.
 */
export function addDeelnemerIdsToAIGeneratedMessages(
  messages: AIGeneratedMessage[],
  deelnemers: Deelnemer[]
): GeneratedMessage[] {
  const deelnemerNameToId = Object.fromEntries(
    deelnemers.map((d) => [d.name, d.id])
  );

  return messages.map((msg) => ({
    ...msg,
    deelnemerId: deelnemerNameToId[msg.deelnemerName],
  }));
}

/**
 * Build the system message for the AI.
 * @param opties - The options for the conversation.
 * @returns The system message for the AI.
 */
const buildSystemMessage = (opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
}) => {
  return `
    # Rol
    Je bent een expert in het schrijven van realistische Nederlandse politieke onderhandelingen. 
    Je schrijft een constructief gesprek tussen politici die tot een compromis proberen te komen.
    
    # Onderwerp
    ${opties.onderwerp}
    
    # Deelnemers
    ${opties.deelnemers
      .map(
        (deelnemer) => `
    - ${deelnemer.name}
      - Partij: ${deelnemer.partij.name}
      - Zetels: ${deelnemer.partij.zetels}
      - Tone of voice: ${deelnemer.toneOfVoice}
      - Standpunten:
          ${deelnemer.partij.programma.standpunten
            .map((standpunt) => `- ${standpunt}`)
            .join("\n\n")}
    `
      )
      .join("\n")}
    
    # Belangrijke Regels
    - Het gesprek moet realistisch en constructief zijn, gericht op het vinden van een compromis
    - Laat politici:
      * Hun standpunten duidelijk maken
      * Naar elkaar luisteren en reageren
      * Kritische vragen stellen
      * Bezwaren uiten maar ook openingen zoeken
      * Langzaam naar elkaar toe bewegen
    - Het gesprek moet een verhaalboog hebben: begin (standpunten), midden (discussie), einde (toenadering)
    - Het gesprek moet eindigen met ruimte voor een compromis of concrete stappen richting oplossing
    - Blijf realistisch: politici blijven hun kernwaarden verdedigen maar zijn bereid te onderhandelen
    - Berichten moeten KORT en PUNTIG zijn (1-3 zinnen max)
    - Politici mogen 2 berichten achter elkaar sturen als ze iets willen verduidelijken
    - Zorg dat politici REAGEREN op wat er net gezegd is. Het is een Ã©chte discussie.
    - Gebruik de partijstandpunten en tone of voice van elke politicus
    - Houd het constructief maar wel met realistische spanning en meningsverschillen
    `;
};

export async function genereerGesprekBerichten(opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
  startAt: Date;
  endAt: Date;
}) {
  const generatedMessages: GeneratedMessage[] = [];
  const systemPrompt = buildSystemMessage(opties);

  let phase: "begin" | "midden" | "einde" = "begin";
  let chunkCount = 0;
  const maxChunks = Math.ceil(
    GESPREK_TARGET_MESSAGES_COUNT / GESPREK_CHUNK_SIZE
  );

  logger.info(
    `Generating ${GESPREK_TARGET_MESSAGES_COUNT} messages in ${maxChunks} chunks of ${GESPREK_CHUNK_SIZE} messages`,
    { phase }
  );

  while (generatedMessages.length < GESPREK_TARGET_MESSAGES_COUNT) {
    chunkCount++;

    const progress = generatedMessages.length / GESPREK_TARGET_MESSAGES_COUNT;

    if (progress < 0.3) {
      phase = "begin";
    } else if (progress < 0.6) {
      phase = "midden";
    } else {
      phase = "einde";
    }

    const isLastChunk =
      chunkCount === maxChunks ||
      generatedMessages.length >=
        GESPREK_TARGET_MESSAGES_COUNT - GESPREK_CHUNK_SIZE;

    const remainingMessages =
      GESPREK_TARGET_MESSAGES_COUNT - generatedMessages.length;

    const messagesThisChunk = Math.min(GESPREK_CHUNK_SIZE, remainingMessages);

    logger.debug(
      `Generating chunk ${chunkCount}/${maxChunks} with ${messagesThisChunk} messages`,
      { phase }
    );

    const conversationHistoryContext =
      generatedMessages.length > 0
        ? `\n## Gesprek tot nu toe:\n${generatedMessages
            .map((m) => `${m.deelnemerName}: ${m.message}`)
            .join("\n")}\n`
        : "";

    const phaseInstructions = {
      begin:
        "Dit is het BEGIN van het gesprek. Laat de politici het onderwerp introduceren en hun standpunten helder uiteenzetten. Toon waar ze van elkaar verschillen.",
      midden:
        "Dit is het MIDDEN van het gesprek. De discussie wordt dieper. Politici stellen kritische vragen, uiten bezwaren, maar beginnen ook overeenkomsten te zien. Toon realistische spanning maar ook openheid.",
      einde:
        "Dit is het EINDE van het gesprek. Politici moeten nu naar elkaar toebewegen. Laat zien dat er ruimte is voor een compromis of dat er concrete vervolgstappen worden gezet. Eindig constructief met perspectief op een oplossing.",
    };

    const userPrompt = isLastChunk
      ? `${conversationHistoryContext}

## Fase: ${phase.toUpperCase()} 
${phaseInstructions[phase]}

DIT IS HET LAATSTE STUK. Genereer ${messagesThisChunk} berichten die het gesprek AFSLUITEN.
Het gesprek moet eindigen met toenadering en perspectief op een compromis of oplossing. 
Laat politici concrete vervolgstappen noemen of ruimte laten voor een gezamenlijke aanpak.`
      : `${conversationHistoryContext}

## Fase: ${phase.toUpperCase()}
${phaseInstructions[phase]}

Genereer de volgende ${messagesThisChunk} berichten van het gesprek.
Zorg dat politici reageren op wat er net gezegd is.`;

    try {
      const response = await generateObject({
        model,
        schema: buildMessageSchema(opties.deelnemers),
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
      });

      const aiMessages = response.object;
      const newMessages = addDeelnemerIdsToAIGeneratedMessages(
        aiMessages,
        opties.deelnemers
      );

      if (newMessages.length === 0) {
        logger.warn(
          `No messages generated for chunk ${chunkCount}`,
          { chunkCount }
        );
        break;
      }

      generatedMessages.push(...newMessages);
      logger.debug(
        `Generated ${newMessages.length} messages for chunk ${chunkCount}`,
        { chunkCount, totalMessages: generatedMessages.length }
      );

      if (generatedMessages.length >= GESPREK_TARGET_MESSAGES_COUNT) {
        break;
      }
    } catch (error) {
      logger.error(
        `Error generating messages for chunk ${chunkCount}`,
        error
      );
      if (generatedMessages.length === 0) {
        throw error;
      }
      break;
    }
  }

  logger.info("Gesprek berichten generation completed", { 
    totalMessages: generatedMessages.length,
    targetMessages: GESPREK_TARGET_MESSAGES_COUNT 
  });

  return addTimestampsToMessages(
    generatedMessages,
    opties.startAt,
    opties.endAt
  );
}
