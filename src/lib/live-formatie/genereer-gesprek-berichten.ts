import { GESPREK_TARGET_MESSAGES_COUNT, GESPREK_CHUNK_SIZE } from "@/config";
import { Deelnemer } from "@/data/deelnemers";
import { model } from "@/lib/ai";
import { generateObject } from "ai";
import { z } from "zod";
import { addTimestampsToMessages } from "../utils";
import { createLogger } from "@/lib/logger";

const logger = createLogger("genereer-gesprek-berichten");

export type GeneratedMessage = {
  message: string;
  deelnemerName: string;
  deelnemerId: number;
};

type AIGeneratedMessage = {
  deelnemerName: string;
  messages: string[]; // 1-3 berichten per burst
};

/**
 * Build a Zod schema for the messages that can be generated by the AI, linked to enumerate of available deelnemers.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns A Zod schema for the messages of the conversation.
 */
export function buildMessageSchema(deelnemers: Deelnemer[]) {
  const deelnemerNames = deelnemers.map((d) => d.name);

  return z.array(
    z.object({
      deelnemerName: z
        .enum(deelnemerNames as [string, ...string[]])
        .describe(
          `De naam van de politicus die deze berichten verstuurt. Moet een van de volgende zijn: ${deelnemerNames.join(
            ", "
          )}`
        ),
      messages: z
        .array(z.string())
        .min(1)
        .max(3)
        .describe(
          "1-3 korte chat-berichten die deze politicus in Ã©Ã©n burst stuurt. Elk bericht is zeer kort (1 zin of minder)."
        ),
    })
  );
}

/**
 * Flatten AI generated message bursts into individual messages and add deelnemer IDs.
 * Each burst (1-3 messages from one politicus) becomes multiple individual GeneratedMessage objects.
 * @param bursts - The generated message bursts from the AI.
 * @param deelnemers - The deelnemers of the conversation.
 * @returns Flattened array of individual messages with deelnemer IDs.
 */
export function addDeelnemerIdsToAIGeneratedMessages(
  bursts: AIGeneratedMessage[],
  deelnemers: Deelnemer[]
): GeneratedMessage[] {
  const deelnemerNameToId = Object.fromEntries(
    deelnemers.map((d) => [d.name, d.id])
  );

  // Flatten bursts into individual messages
  const flattenedMessages: GeneratedMessage[] = [];
  
  for (const burst of bursts) {
    const deelnemerId = deelnemerNameToId[burst.deelnemerName];
    
    for (const message of burst.messages) {
      flattenedMessages.push({
        message,
        deelnemerName: burst.deelnemerName,
        deelnemerId,
      });
    }
  }

  return flattenedMessages;
}

/**
 * Build the system message for the AI.
 * @param opties - The options for the conversation.
 * @returns The system message for the AI.
 */
const buildSystemMessage = (opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
}) => {
  return `
    # Rol
    Je bent een expert in het schrijven van realistische Nederlandse politieke onderhandelingen. 
    Je schrijft een constructief gesprek tussen politici die tot een compromis proberen te komen.
    
    # Onderwerp
    ${opties.onderwerp}
    
    # Deelnemers
    ${opties.deelnemers
      .map(
        (deelnemer) => `
    - ${deelnemer.name}
      - Partij: ${deelnemer.partij.name}
      - Zetels: ${deelnemer.partij.zetels}
      - Tone of voice: ${deelnemer.toneOfVoice}${
          deelnemer.persoonlijkeDetails
            ? `\n      - Achtergrond: ${deelnemer.persoonlijkeDetails}`
            : ""
        }${
          deelnemer.typischeUitspraken && deelnemer.typischeUitspraken.length > 0
            ? `\n      - Typische uitspraken: ${deelnemer.typischeUitspraken.join("; ")}`
            : ""
        }
      - Standpunten:
          ${deelnemer.partij.programma.standpunten
            .map((standpunt) => `- ${standpunt}`)
            .join("\n          ")}
    `
      )
      .join("\n")}
    
    # Belangrijke Regels
    - Het gesprek moet realistisch en constructief zijn, gericht op het vinden van een compromis
    - Laat politici:
      * Hun standpunten duidelijk maken
      * Naar elkaar luisteren en reageren
      * Kritische vragen stellen
      * Bezwaren uiten maar ook openingen zoeken
      * Langzaam naar elkaar toe bewegen
    - Het gesprek moet een verhaalboog hebben: begin (standpunten), midden (discussie), einde (toenadering)
    - Het gesprek moet eindigen met ruimte voor een compromis of concrete stappen richting oplossing
    - Blijf realistisch: politici blijven hun kernwaarden verdedigen maar zijn bereid te onderhandelen
    
    # Chat-stijl Format
    - Dit is een GROEPSCHAT. Politici sturen korte, snelle berichten zoals in WhatsApp
    - Elk persoon stuurt 1-3 berichten per beurt (een "burst")
    - Berichten zijn ZEER KORT:
      * Meestal 1 korte zin
      * Soms halve zinnen of uitroepen: "Precies!", "Dat slaat nergens op.", "Kom op zeg."
      * Maximum 15-20 woorden per bericht
    - Emojis zijn toegestaan en moeten spaarzaam gebruikt worden:
      * Vooral door jongere/informelere politici (Rob Jetten, Laurens Dassen)
      * Voorbeelden: ğŸ”¥ ğŸ’ª ğŸ¤” âœ… âŒ ğŸ‘ ğŸ˜… ğŸ¯
      * Oudere/formelere politici gebruiken zelden of nooit emojis
    - Bursts kunnen zijn:
      * EÃ©n gedachte opgebroken in delen: ["Dat vind ik te kort door de bocht.", "We moeten dit serieus uitwerken."]
      * Snelle reacties achter elkaar: ["Precies! ğŸ‘", "Daar ben ik het volledig mee eens."]
      * Opbouwen naar een punt: ["Even eerlijk zijn.", "Dit gaat nergens over.", "We hebben een beter plan nodig."]
    - REAGEER op wat er net gezegd is. Dit is een Ã©chte, dynamische discussie.
    - Gebruik de partijstandpunten en tone of voice van elke politicus
    - Houd het constructief maar wel met realistische spanning en meningsverschillen
    `;
};

export async function genereerGesprekBerichten(opties: {
  onderwerp: string;
  deelnemers: Deelnemer[];
  startAt: Date;
  endAt: Date;
}) {
  const generatedMessages: GeneratedMessage[] = [];
  const systemPrompt = buildSystemMessage(opties);

  let phase: "begin" | "midden" | "einde" = "begin";
  let chunkCount = 0;
  const maxChunks = Math.ceil(
    GESPREK_TARGET_MESSAGES_COUNT / GESPREK_CHUNK_SIZE
  );

  logger.info(
    `Generating ${GESPREK_TARGET_MESSAGES_COUNT} messages in ${maxChunks} chunks of ${GESPREK_CHUNK_SIZE} messages`,
    { phase }
  );

  while (generatedMessages.length < GESPREK_TARGET_MESSAGES_COUNT) {
    chunkCount++;

    const progress = generatedMessages.length / GESPREK_TARGET_MESSAGES_COUNT;

    if (progress < 0.3) {
      phase = "begin";
    } else if (progress < 0.6) {
      phase = "midden";
    } else {
      phase = "einde";
    }

    const isLastChunk =
      chunkCount === maxChunks ||
      generatedMessages.length >=
        GESPREK_TARGET_MESSAGES_COUNT - GESPREK_CHUNK_SIZE;

    const remainingMessages =
      GESPREK_TARGET_MESSAGES_COUNT - generatedMessages.length;

    const messagesThisChunk = Math.min(GESPREK_CHUNK_SIZE, remainingMessages);

    logger.debug(
      `Generating chunk ${chunkCount}/${maxChunks} with ${messagesThisChunk} messages`,
      { phase }
    );

    const conversationHistoryContext =
      generatedMessages.length > 0
        ? `\n## Gesprek tot nu toe:\n${generatedMessages
            .map((m) => `${m.deelnemerName}: ${m.message}`)
            .join("\n")}\n`
        : "";

    const phaseInstructions = {
      begin:
        "Dit is het BEGIN van het gesprek. Laat de politici het onderwerp introduceren en hun standpunten helder uiteenzetten. Toon waar ze van elkaar verschillen.",
      midden:
        "Dit is het MIDDEN van het gesprek. De discussie wordt dieper. Politici stellen kritische vragen, uiten bezwaren, maar beginnen ook overeenkomsten te zien. Toon realistische spanning maar ook openheid.",
      einde:
        "Dit is het EINDE van het gesprek. Politici moeten nu naar elkaar toebewegen. Laat zien dat er ruimte is voor een compromis of dat er concrete vervolgstappen worden gezet. Eindig constructief met perspectief op een oplossing.",
    };

    const userPrompt = isLastChunk
      ? `${conversationHistoryContext}

## Fase: ${phase.toUpperCase()} 
${phaseInstructions[phase]}

DIT IS HET LAATSTE STUK. Genereer ${messagesThisChunk} berichten die het gesprek AFSLUITEN.
Het gesprek moet eindigen met toenadering en perspectief op een compromis of oplossing. 
Laat politici concrete vervolgstappen noemen of ruimte laten voor een gezamenlijke aanpak.`
      : `${conversationHistoryContext}

## Fase: ${phase.toUpperCase()}
${phaseInstructions[phase]}

Genereer de volgende ${messagesThisChunk} berichten van het gesprek.
Zorg dat politici reageren op wat er net gezegd is.`;

    try {
      const response = await generateObject({
        model,
        schema: buildMessageSchema(opties.deelnemers),
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
      });

      const aiMessages = response.object;
      const newMessages = addDeelnemerIdsToAIGeneratedMessages(
        aiMessages,
        opties.deelnemers
      );

      if (newMessages.length === 0) {
        logger.warn(
          `No messages generated for chunk ${chunkCount}`,
          { chunkCount }
        );
        break;
      }

      generatedMessages.push(...newMessages);
      logger.debug(
        `Generated ${newMessages.length} messages for chunk ${chunkCount}`,
        { chunkCount, totalMessages: generatedMessages.length }
      );

      if (generatedMessages.length >= GESPREK_TARGET_MESSAGES_COUNT) {
        break;
      }
    } catch (error) {
      logger.error(
        `Error generating messages for chunk ${chunkCount}`,
        error
      );
      if (generatedMessages.length === 0) {
        throw error;
      }
      break;
    }
  }

  logger.info("Gesprek berichten generation completed", { 
    totalMessages: generatedMessages.length,
    targetMessages: GESPREK_TARGET_MESSAGES_COUNT 
  });

  return addTimestampsToMessages(
    generatedMessages,
    opties.startAt,
    opties.endAt
  );
}
